[« previous](03-routing.md) | [next »](05-utilities.md)

## 4. Internationalization (i18n)
Within this chapter we not only are going to build a solution to replace static texts
with translations, but also provide the fundamentals for localization.

> **Localization** refers to the adaptation of a product, application or document content to meet the language,
> cultural and other requirements of a specific target market (a locale).
> 
> **Internationalization** is the design and development of a product, application or document content that enables
> easy localization for target audiences that vary in culture, region, or language.
>
> `https://www.w3.org/International/questions/qa-i18n.en, 2022-05-24`

With this definition it should be clear that internationalization (i18n) is not only about translations,
but also about localization like time and date formats. So in an i18n supportive application is crucial to have
access to a globally available information which describes the language and the region.
As an example, the browser's `window.navigator` goes with
[RFC 5646: Tags for Identifying Languages (also known as BCP 47)](https://datatracker.ietf.org/doc/html/rfc5646)
for such information. Language and localization info are written in the following format `[language id]-[COUNTRY CODE]`
(e.g. `en-US` or `de-CH`). So it might be a good practise to go with.

We could handle i18n stuff with a fancy library like [i18next](https://www.i18next.com/),
but this library is definitely an overkill for our plans in this tutorial.
With the code we are going to write in this chapter, it should be no problem to implement an
[adapter](https://www.geeksforgeeks.org/adapter-pattern/) for i18next
at later times, without refactoring all our components using our i18n package.

### 4.1 Create the i18n core package

TBD

```typescript
// src/packages/core/i18n/i18n.ts
import { createContext, useContext } from 'react';

export type LanguageCode = 'en-US' | 'en-GB' | 'de-CH';

function getLanguageId(languageCode: LanguageCode): string {
    const separator = '-';
    const languageCodeParts = languageCode.split(separator);
    languageCodeParts.pop();
    return languageCodeParts.join(separator);
}

export type I18n = {
    ampm: boolean;
    languageCode: LanguageCode;
};

export function createI18n(languageCode: LanguageCode = 'en-US'): I18n {
    return {
        ampm: getLanguageId(languageCode) === 'en',
        languageCode: languageCode,
    };
}

const context = createContext<null | I18n>(null);

export const I18nProvider = context.Provider;

export function useI18n(): I18n {
    const state = useContext(context);
    if (!state) {
        throw new Error('no i18n was provided');
    }
    return state;
}
```

TBD

```typescript
// src/packages/core/i18n/translator.ts

import { createContext, useContext } from 'react';
import { useI18n } from './i18n';

export type TranslationPlaceholders = {
    [key: string]: string;
};

export type Translation = {
    id: string;
    placeholders?: TranslationPlaceholders;
};

export type Translator = {
    t: (translationId: string, placeholders?: TranslationPlaceholders) => string;
};

const translatorContext = createContext<null | Translator>(null);

export const TranslatorProvider = translatorContext.Provider;

export function useTranslator(): Translator {
    useI18n(); // make sure translations are rendered whenever the i18n state does change
    const translator = useContext(translatorContext);
    if (!translator) {
        throw new Error('No Translator was provided');
    }
    return translator;
}
```

TBD

```typescript
// src/packages/core/i18n/index.ts
export * from './i18n';
export * from './translator';
```

This is a hard one... TBD

```typescript
// src/packages/core/i18n/T.tsx

import { FC, Fragment, ReactNode } from 'react';
import { Translation, useTranslator } from './translator';

type Placeholders = {
    [key: string]: string | ReactNode;
};

type TextWithPlaceholdersProps = {
    text: string;
    placeholders: Placeholders;
};

const TextWithPlaceholders: FC<TextWithPlaceholdersProps> = (props) => {
    const placeholderKeys = Object.keys(props.placeholders);
    if (!placeholderKeys.length) {
        return <>{props.text}</>;
    }
    const placeholderKey = placeholderKeys[0];
    const placeholderValue = props.placeholders[placeholderKey];
    let nextPlaceholders: Placeholders = { ...props.placeholders };
    delete nextPlaceholders[placeholderKey];
    const textParts = props.text.split(`{{${placeholderKey}}}`);
    const textPartsWithPlaceholders: ReactNode[] = textParts.map((textPart) => (
        <TextWithPlaceholders text={textPart} placeholders={nextPlaceholders} />
));
    return (
        <>
            {textPartsWithPlaceholders.reduce((prev, curr, index) => {
                return [
                    <Fragment key={'prev' + index}>{prev}</Fragment>,
                        <Fragment key={'placeholder' + index}>{placeholderValue}</Fragment>,
                        <Fragment key={'curr' + index}>{curr}</Fragment>,
                ];
            })}
        </>
    );
};

export type TProps = Omit<Translation, 'placeholders'> & {
    placeholders?: Placeholders;
};

export const T: FC<TProps> = (props) => {
    const { t } = useTranslator();
    const text = t(props.id);
    if (!props.placeholders) {
        return <>{text}</>;
    }
    return <TextWithPlaceholders text={text} placeholders={props.placeholders} />;
};
```

Also add this one to the `index.ts` file export: `export * from './T';`.

### 4.x Crafting the translator's implementation
TBD

```typescript
// src/packages/core/i18n/dictionaryTranslator.tsx

import { TranslationPlaceholders, Translator } from './translator';

export type Dictionary = {
    [key: string]: string | Dictionary;
};

function findNestedProp(dictionary: Dictionary, translationId: string): null | string {
    const translationIdParts = translationId.split('.');
    if (translationIdParts.length === 1) {
        const key = translationIdParts[0];
        if (dictionary[key] === undefined) {
            return null;
        }
        const translationContent = dictionary[key];
        if (typeof translationContent === 'string') {
            return translationContent;
        }
        console.error(`Invalid translationId "${translationId}": Translation is not a string`);
        return null;
    }
    const key = translationIdParts[0];
    if (dictionary[key] === undefined) {
        return null;
    }
    const subDictionary = dictionary[key];
    if (typeof subDictionary !== 'object') {
        return null;
    }
    const subTranslationId = translationIdParts.slice(1).join('.');
    return findNestedProp(subDictionary, subTranslationId);
}

export class DictionaryTranslator implements Translator {
    private dictionary: Dictionary;

    constructor(dictionary: Dictionary) {
        this.dictionary = dictionary;
        this.t = this.t.bind(this);
    }

    setDictionary(dictionary: Dictionary) {
        this.dictionary = dictionary;
    }

    t(translationId: string, placeholders?: TranslationPlaceholders): string {
        let translation = findNestedProp(this.dictionary, translationId);
        if (translation === null) {
            return translationId;
        }
        if (!placeholders) {
            return translation;
        }
        Object.keys(placeholders).forEach((placeholderKey) => {
            const placeholderValue = placeholders[placeholderKey];
            if (translation === null) {
                throw new Error(`this case should have been handled by an early return beforehand`);
            }
            translation = translation.replaceAll('{{' + placeholderKey + '}}', placeholderValue);
        });
        return translation;
    }
}
```

Please don't forget to export this class as well!

## 4.x Provide i18n state and the translator
tbd

todo
https://github.com/inkognitro/react-app-tutorial-code/compare/03-routing-2...04-i18n-1
- TestServiceProvider.tsx
- ServiceProvider.tsx
- NavBarPage.tsx

Define in components because it affects the app as a whole.
For other apps it could make sense to implement other translations.

```typescript
// src/components/translations.tsx
{
    "core": {
        "currentUser": {
            "guestDisplayName": "Guest"
        },
        "nav": {
            "logout": "Logout",
                "login": "Login",
                "signUp": "Sign Up",
                "mySettings": "Settings"
        }
    },
}

```

```json
// src/pages/IndexPage.tsx

```

## 4.x Translating the contents in our `NavBar`
tbd
```typescript
// src/pages/IndexPage.tsx

```

## 4.x Using React component placeholders

add:
```json
// src/components/translations/enUS.json
"pages": {
        "indexPage": {
        "greeting": "Hi {{username}}!"
    }
}
```

tbd
```typescript
// src/pages/IndexPage.tsx

import { FC } from 'react';
import { NavBarPage } from '@components/page-layout';
import { T, useTranslator } from '@packages/core/i18n';
import { useCurrentUser } from '@packages/core/auth';

export const IndexPage: FC = () => {
    return <NavBarPage title="Home">Home.</NavBarPage>;
    const { t } = useTranslator();
    const currentUser = useCurrentUser();
    const username =
        currentUser.type === 'authenticated' ? currentUser.data.username : t('core.currentUser.guestDisplayName');
    return (
        <NavBarPage title="Home">
            <T id="pages.indexPage.greeting" placeholders={{ username: <strong>{username}</strong> }} />
        </NavBarPage>
    );
};
```

[« previous](03-routing.md) | [next »](05-utilities.md)